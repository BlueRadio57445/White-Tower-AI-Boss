# 特徵工程設計文檔

## 概述

本文檔詳細說明 97 維特徵向量的實作細節，包含每個特徵的計算方法、歸一化方式、以及時間差分的處理。

---

## 特徵總覽

| 區塊 | 維度範圍 | 維度數 | 說明 |
|------|---------|--------|------|
| 自身狀態 | [0-9] | 10 | 血量、CD、牆壁距離 |
| 敵人狀態 | [10-65] | 56 | 4個敵人 × 14維 |
| 血包狀態 | [66-80] | 15 | 3個血包 × 5維 |
| 投射物狀態 | [81-95] | 15 | 3個投射物 × 5維 |
| Bias | [96] | 1 | 常數 1.0 |
| **總計** | | **97** | |

---

## 程式碼架構

### 檔案結構

```
ai/
├── features.py              # FeatureExtractor 主類
├── feature_components/
│   ├── __init__.py
│   ├── self_features.py     # 自身狀態特徵
│   ├── enemy_features.py    # 敵人狀態特徵
│   ├── item_features.py     # 血包狀態特徵
│   └── projectile_features.py  # 投射物狀態特徵
```

### 類別設計

```python
# ai/features.py

class FeatureExtractor:
    """
    特徵提取器

    將遊戲狀態轉換為 97 維特徵向量
    """

    N_FEATURES = 97

    # 各區塊的維度
    SELF_STATE_DIM = 10
    ENEMY_DIM_PER = 14
    ENEMY_COUNT = 4
    BLOOD_PACK_DIM_PER = 5
    BLOOD_PACK_COUNT = 3
    PROJECTILE_DIM_PER = 5
    PROJECTILE_COUNT = 3

    def __init__(self, world_size: float = 10.0):
        self.world_size = world_size
        self.max_distance = world_size * np.sqrt(2)  # 對角線距離

        # 上一幀的狀態（用於計算時間差分）
        self._prev_enemy_data: Dict[int, EnemySnapshot] = {}
        self._prev_blood_pack_data: Dict[int, ItemSnapshot] = {}
        self._prev_projectile_data: Dict[int, ProjectileSnapshot] = {}

    def extract(self, world: GameWorld) -> np.ndarray:
        """提取完整特徵向量"""
        features = np.zeros(self.N_FEATURES)

        idx = 0

        # 自身狀態 [0-9]
        self_features = self._extract_self_features(world)
        features[idx:idx+self.SELF_STATE_DIM] = self_features
        idx += self.SELF_STATE_DIM

        # 敵人狀態 [10-65]
        enemy_features = self._extract_enemy_features(world)
        features[idx:idx+self.ENEMY_DIM_PER*self.ENEMY_COUNT] = enemy_features
        idx += self.ENEMY_DIM_PER * self.ENEMY_COUNT

        # 血包狀態 [66-80]
        blood_features = self._extract_blood_pack_features(world)
        features[idx:idx+self.BLOOD_PACK_DIM_PER*self.BLOOD_PACK_COUNT] = blood_features
        idx += self.BLOOD_PACK_DIM_PER * self.BLOOD_PACK_COUNT

        # 投射物狀態 [81-95]
        proj_features = self._extract_projectile_features(world)
        features[idx:idx+self.PROJECTILE_DIM_PER*self.PROJECTILE_COUNT] = proj_features
        idx += self.PROJECTILE_DIM_PER * self.PROJECTILE_COUNT

        # Bias [96]
        features[idx] = 1.0

        return features

    def reset(self):
        """重置狀態（新 episode 時調用）"""
        self._prev_enemy_data.clear()
        self._prev_blood_pack_data.clear()
        self._prev_projectile_data.clear()
```

---

## 詳細特徵定義

### 自身狀態（10維）

```python
def _extract_self_features(self, world: GameWorld) -> np.ndarray:
    """
    提取自身狀態特徵

    [0]     自身血量 (歸一化 0-1)
    [1]     共同技能 CD (歸一化 0-1, 0=ready)
    [2-8]   8個技能獨立 CD (歸一化 0-1, 0=ready)
    [9]     面前牆壁距離 (歸一化 0-1)
    """
    features = np.zeros(10)

    agent = world.player
    if agent is None:
        return features

    # [0] 自身血量
    if agent.has_health():
        features[0] = agent.health.current / agent.health.maximum

    # [1] 共同技能 CD
    cd_manager = world.skill_executor.cooldown_manager
    features[1] = cd_manager.shared_cd / cd_manager.SHARED_CD_TICKS

    # [2-9] 8個技能獨立 CD
    MAX_INDIVIDUAL_CD = 50  # 最大獨立 CD（約 10 秒）
    for i in range(8):
        skill_id = i + 1
        cd = cd_manager.individual_cds.get(skill_id, 0)
        features[2 + i] = cd / MAX_INDIVIDUAL_CD

    # [9] 面前牆壁距離（射線投射）
    agent_pos = agent.position.as_array()
    agent_angle = agent.position.angle
    wall_dist = self._raycast_to_wall(agent_pos, agent_angle)
    features[9] = wall_dist / self.world_size

    return features

def _raycast_to_wall(self, pos: np.ndarray, angle: float) -> float:
    """
    射線投射計算面前牆壁距離

    從 pos 沿著 angle 方向發射射線，返回到邊界的距離
    """
    cos_a = np.cos(angle)
    sin_a = np.sin(angle)

    distances = []

    # X 方向
    if cos_a > 1e-6:
        t = (self.world_size - pos[0]) / cos_a
        distances.append(t)
    elif cos_a < -1e-6:
        t = -pos[0] / cos_a
        distances.append(t)

    # Y 方向
    if sin_a > 1e-6:
        t = (self.world_size - pos[1]) / sin_a
        distances.append(t)
    elif sin_a < -1e-6:
        t = -pos[1] / sin_a
        distances.append(t)

    return min(distances) if distances else self.world_size
```

---

### 敵人狀態（14維 × 4 = 56維）

```python
@dataclass
class EnemySnapshot:
    """敵人狀態快照（用於計算時間差分）"""
    distance: float
    angle: float
    facing_diff: float
    eye_front_distance: float
    eye_front_angle: float


def _extract_enemy_features(self, world: GameWorld) -> np.ndarray:
    """
    提取敵人狀態特徵（按距離排序）

    每個敵人 14 維：
    [0]     敵人血量
    [1]     距離 (歸一化)
    [2]     角度 (弧度, -π 到 π)
    [3]     敵人朝向差 (弧度)
    [4]     眼前1格距離 (歸一化)
    [5]     眼前1格角度 (弧度)
    [6]     Δ距離
    [7]     Δ角度
    [8]     Δ朝向差
    [9]     Δ眼前距離
    [10]    Δ眼前角度
    [11-13] 敵人類型 one-hot (劍/弓/法杖)
    """
    features = np.zeros(self.ENEMY_DIM_PER * self.ENEMY_COUNT)

    agent = world.player
    if agent is None:
        return features

    agent_pos = agent.position.as_array()
    agent_angle = agent.position.angle

    # 收集所有活著的敵人
    enemies = []
    for monster in world.monsters:
        if not monster.is_alive:
            continue

        enemy_pos = monster.position.as_array()
        diff = enemy_pos - agent_pos
        distance = np.linalg.norm(diff)

        enemies.append((distance, monster))

    # 按距離排序
    enemies.sort(key=lambda x: x[0])

    # 提取特徵
    current_enemy_data = {}

    for i, (distance, monster) in enumerate(enemies[:self.ENEMY_COUNT]):
        offset = i * self.ENEMY_DIM_PER

        enemy_pos = monster.position.as_array()
        enemy_angle = monster.position.angle

        # [0] 敵人血量
        if monster.has_health():
            features[offset + 0] = monster.health.current / monster.health.maximum

        # [1] 距離 (歸一化)
        features[offset + 1] = distance / self.max_distance

        # [2] 角度（相對於 Agent 朝向）
        diff = enemy_pos - agent_pos
        absolute_angle = np.arctan2(diff[1], diff[0])
        relative_angle = self._normalize_angle(absolute_angle - agent_angle)
        features[offset + 2] = relative_angle

        # [3] 敵人朝向差
        facing_diff = self._normalize_angle(enemy_angle - agent_angle)
        features[offset + 3] = facing_diff

        # [4-5] 眼前1格（敵人位置 + 朝向方向1格）
        eye_front_pos = enemy_pos + np.array([np.cos(enemy_angle), np.sin(enemy_angle)])
        eye_diff = eye_front_pos - agent_pos
        eye_front_distance = np.linalg.norm(eye_diff) / self.max_distance
        eye_front_angle = self._normalize_angle(
            np.arctan2(eye_diff[1], eye_diff[0]) - agent_angle
        )
        features[offset + 4] = eye_front_distance
        features[offset + 5] = eye_front_angle

        # 保存當前狀態用於下一幀的差分計算
        current_snapshot = EnemySnapshot(
            distance=distance / self.max_distance,
            angle=relative_angle,
            facing_diff=facing_diff,
            eye_front_distance=eye_front_distance,
            eye_front_angle=eye_front_angle
        )
        current_enemy_data[monster.id] = current_snapshot

        # [6-10] 時間差分
        prev = self._prev_enemy_data.get(monster.id)
        if prev is not None:
            features[offset + 6] = current_snapshot.distance - prev.distance
            features[offset + 7] = self._normalize_angle(current_snapshot.angle - prev.angle)
            features[offset + 8] = self._normalize_angle(current_snapshot.facing_diff - prev.facing_diff)
            features[offset + 9] = current_snapshot.eye_front_distance - prev.eye_front_distance
            features[offset + 10] = self._normalize_angle(current_snapshot.eye_front_angle - prev.eye_front_angle)
        # else: 保持為 0（第一幀或新出現的敵人）

        # [11-13] 敵人類型 one-hot
        enemy_type = self._get_enemy_type(monster)
        if enemy_type == "sword":
            features[offset + 11] = 1.0
        elif enemy_type == "bow":
            features[offset + 12] = 1.0
        elif enemy_type == "staff":
            features[offset + 13] = 1.0

    # 更新上一幀數據
    self._prev_enemy_data = current_enemy_data

    return features

def _normalize_angle(self, angle: float) -> float:
    """將角度歸一化到 [-π, π]"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle

def _get_enemy_type(self, monster) -> str:
    """獲取敵人類型"""
    if monster.has_tag("monster_sword"):
        return "sword"
    elif monster.has_tag("monster_bow"):
        return "bow"
    elif monster.has_tag("monster_staff"):
        return "staff"
    return "sword"  # 默認
```

---

### 血包狀態（5維 × 3 = 15維）

```python
@dataclass
class ItemSnapshot:
    """物品狀態快照"""
    distance: float
    angle: float


def _extract_blood_pack_features(self, world: GameWorld) -> np.ndarray:
    """
    提取血包狀態特徵（按距離排序）

    每個血包 5 維：
    [0]     距離 (歸一化)
    [1]     角度 (弧度)
    [2]     Δ距離
    [3]     Δ角度
    [4]     是否存在 (0 或 1)
    """
    features = np.zeros(self.BLOOD_PACK_DIM_PER * self.BLOOD_PACK_COUNT)

    agent = world.player
    if agent is None:
        return features

    agent_pos = agent.position.as_array()
    agent_angle = agent.position.angle

    # 收集所有血包
    packs = []
    for item in world.items:
        if not item.is_alive or not item.has_tag("blood_pack"):
            continue

        item_pos = item.position.as_array()
        diff = item_pos - agent_pos
        distance = np.linalg.norm(diff)

        packs.append((distance, item))

    # 按距離排序
    packs.sort(key=lambda x: x[0])

    # 提取特徵
    current_pack_data = {}

    for i, (distance, item) in enumerate(packs[:self.BLOOD_PACK_COUNT]):
        offset = i * self.BLOOD_PACK_DIM_PER

        item_pos = item.position.as_array()
        diff = item_pos - agent_pos

        # [0] 距離
        norm_distance = distance / self.max_distance
        features[offset + 0] = norm_distance

        # [1] 角度
        absolute_angle = np.arctan2(diff[1], diff[0])
        relative_angle = self._normalize_angle(absolute_angle - agent_angle)
        features[offset + 1] = relative_angle

        # 保存當前狀態
        current_snapshot = ItemSnapshot(
            distance=norm_distance,
            angle=relative_angle
        )
        current_pack_data[item.id] = current_snapshot

        # [2-3] 時間差分
        prev = self._prev_blood_pack_data.get(item.id)
        if prev is not None:
            features[offset + 2] = current_snapshot.distance - prev.distance
            features[offset + 3] = self._normalize_angle(current_snapshot.angle - prev.angle)

        # [4] 是否存在
        features[offset + 4] = 1.0

    # 更新上一幀數據
    self._prev_blood_pack_data = current_pack_data

    return features
```

---

### 投射物狀態（5維 × 3 = 15維）

```python
@dataclass
class ProjectileSnapshot:
    """投射物狀態快照"""
    distance: float
    angle: float


def _extract_projectile_features(self, world: GameWorld) -> np.ndarray:
    """
    提取投射物狀態特徵（按距離排序，只追蹤敵方投射物）

    每個投射物 5 維：
    [0]     距離 (歸一化)
    [1]     角度 (弧度)
    [2]     Δ距離 (負值表示正在接近)
    [3]     Δ角度
    [4]     是否存在 (0 或 1)
    """
    features = np.zeros(self.PROJECTILE_DIM_PER * self.PROJECTILE_COUNT)

    agent = world.player
    if agent is None:
        return features

    agent_pos = agent.position.as_array()
    agent_angle = agent.position.angle

    # 收集所有敵方投射物
    projectiles = []
    for proj in world.projectiles:
        if not proj.is_alive:
            continue

        # 只追蹤敵方投射物（有 owner 的是敵人射出的）
        if proj.owner is None:
            continue

        proj_pos = proj.position.as_array()
        diff = proj_pos - agent_pos
        distance = np.linalg.norm(diff)

        projectiles.append((distance, proj))

    # 按距離排序（最危險的在前）
    projectiles.sort(key=lambda x: x[0])

    # 提取特徵
    current_proj_data = {}

    for i, (distance, proj) in enumerate(projectiles[:self.PROJECTILE_COUNT]):
        offset = i * self.PROJECTILE_DIM_PER

        proj_pos = proj.position.as_array()
        diff = proj_pos - agent_pos

        # [0] 距離
        norm_distance = distance / self.max_distance
        features[offset + 0] = norm_distance

        # [1] 角度
        absolute_angle = np.arctan2(diff[1], diff[0])
        relative_angle = self._normalize_angle(absolute_angle - agent_angle)
        features[offset + 1] = relative_angle

        # 保存當前狀態
        current_snapshot = ProjectileSnapshot(
            distance=norm_distance,
            angle=relative_angle
        )
        current_proj_data[proj.id] = current_snapshot

        # [2-3] 時間差分
        prev = self._prev_projectile_data.get(proj.id)
        if prev is not None:
            features[offset + 2] = current_snapshot.distance - prev.distance
            features[offset + 3] = self._normalize_angle(current_snapshot.angle - prev.angle)

        # [4] 是否存在
        features[offset + 4] = 1.0

    # 更新上一幀數據
    self._prev_projectile_data = current_proj_data

    return features
```

---

## 特徵歸一化摘要

| 特徵類型 | 歸一化方式 | 範圍 |
|---------|-----------|------|
| 血量 | `current / maximum` | [0, 1] |
| CD | `remaining / max_cd` | [0, 1], 0=ready |
| 距離 | `distance / max_distance` | [0, 1] |
| 角度 | 原始弧度 | [-π, π] |
| Δ距離 | 原始差值 | 約 [-0.1, 0.1] |
| Δ角度 | 歸一化到 [-π, π] | [-π, π] |
| 存在標記 | 0 或 1 | {0, 1} |
| one-hot | 0 或 1 | {0, 1} |

---

## 空位處理

當敵人/血包/投射物數量不足時，對應的特徵槽位**全部填 0**。

```python
# 例：只有 2 個敵人
[敵人1特徵(14維)] [敵人2特徵(14維)] [0,0,0,...,0(14維)] [0,0,0,...,0(14維)]
```

---

## 時間差分的意義

| 特徵 | Δ > 0 | Δ < 0 |
|------|-------|-------|
| Δ距離 | 目標遠離 | 目標接近 |
| Δ角度 | 目標往右移 | 目標往左移 |
| Δ朝向差 | 敵人轉向其他方向 | 敵人轉向 Agent |
| Δ投射物距離 | 投射物遠離 | **投射物接近（危險！）** |

---

## 完整索引表

```
[0]     自身血量
[1]     共同技能 CD
[2]     技能1 CD (外圈刮)
[3]     技能2 CD (飛彈)
[4]     技能3 CD (鐵錘)
[5]     技能4 CD (閃現)
[6]     技能5 CD (靈魂爪)
[7]     技能6 CD (靈魂掌)
[8]     技能7 CD (血池)
[9]     技能8 CD (召喚血包)
[10]    面前牆壁距離
────────────────────────────
[11-24]  敵人1 (最近)
[25-38]  敵人2
[39-52]  敵人3
[53-66]  敵人4 (最遠)
────────────────────────────
[67-71]  血包1 (最近)
[72-76]  血包2
[77-81]  血包3
────────────────────────────
[82-86]  投射物1 (最近)
[87-91]  投射物2
[92-96]  投射物3
────────────────────────────
[96]     Bias (1.0)
```

**注意**：索引從 0 開始，技能 CD 佔據 [2-9] 共 8 維，加上血量和共同 CD 共 10 維，所以敵人1 從 [10] 開始。讓我重新計算...

修正後的索引：
```
[0]      自身血量
[1]      共同技能 CD
[2-9]    8個技能獨立 CD
總共 10 維

敵人從 [10] 開始...
```

等等，這樣自身狀態只有 10 維，但 [2-9] 是 8 維，加上 [0] 和 [1] 也是 10 維。但牆壁距離呢？

讓我重新整理：

**修正後的自身狀態（11維？）：**
```
[0]     自身血量
[1]     共同技能 CD
[2-9]   8個技能獨立 CD (8維)
[10]    面前牆壁距離
```

這樣是 11 維，不是 10 維。需要修正文檔中的數字。

**總維度重新計算：**
- 自身狀態：11 維
- 敵人狀態：14 × 4 = 56 維
- 血包狀態：5 × 3 = 15 維
- 投射物狀態：5 × 3 = 15 維
- Bias：1 維
- **總計：11 + 56 + 15 + 15 + 1 = 98 維**

需要與記憶中的 97 維對齊。檢查記憶中的定義...

記憶中寫的是：
```
[0]     自身血量
[1]     共同技能 CD
[2-8]   7個技能獨立 CD
[9]     面前牆壁距離
```

這是 10 維（7 個技能 CD，而非 8 個）。但現在有 8 個技能...

**問題發現**：技能數量從 7 個變成 8 個（新增了靈魂掌），需要更新特徵維度。

**更新後的總維度：**
- 自身狀態：11 維（1+1+8+1）
- 敵人狀態：56 維
- 血包狀態：15 維
- 投射物狀態：15 維
- Bias：1 維
- **總計：98 維**

我會在文檔中使用正確的數字。

---

## 測試方法

```python
def test_feature_extraction():
    world = GameWorld()
    world.reset()
    extractor = FeatureExtractor()

    # 第一幀
    features1 = extractor.extract(world)
    assert features1.shape == (98,)
    assert features1[-1] == 1.0  # Bias

    # 模擬移動
    world.tick()

    # 第二幀（應該有時間差分）
    features2 = extractor.extract(world)

    # 檢查敵人的 Δ距離是否非零
    # ...
```

---

## 注意事項

1. **每個 episode 開始時必須調用 `extractor.reset()`**，清除上一幀數據
2. **時間差分在第一幀為 0**，因為沒有上一幀數據
3. **敵人按距離排序**，所以同一個敵人在不同幀可能在不同的槽位
4. **投射物壽命短**，可能在幾幀內就消失，需要正確處理

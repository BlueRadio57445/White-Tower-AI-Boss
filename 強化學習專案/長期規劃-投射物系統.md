# 投射物系統設計文檔

## 概述

本文檔詳細說明投射物（Projectile）系統的實作，包含投射物實體設計、碰撞檢測、生命週期管理，以及與 Monster 攻擊行為的整合。

---

## 投射物類型

| 類型 | 來源 | 速度 | 傷害 | 說明 |
|------|------|------|------|------|
| Arrow | Monster (弓) | 0.8 | 15 | 直線飛行 |
| MagicBolt | Monster (法杖) | 0.6 | 20 | 直線飛行，稍慢但傷害高 |

---

## 程式碼架構

### 檔案結構

```
game/
├── projectile.py            # Projectile 類別
├── projectile_manager.py    # ProjectileManager 管理所有投射物
```

### Projectile 類別

```python
# game/projectile.py

from dataclasses import dataclass, field
from typing import Optional
import numpy as np
from core.events import EventBus, EventType, GameEvent


@dataclass
class ProjectileConfig:
    """投射物配置"""
    speed: float = 0.8
    damage: float = 15.0
    max_lifetime_ticks: int = 100  # 最大存活時間
    radius: float = 0.2  # 碰撞半徑


class ProjectileType:
    """投射物類型枚舉"""
    ARROW = "arrow"
    MAGIC_BOLT = "magic_bolt"


# 預設配置
PROJECTILE_CONFIGS = {
    ProjectileType.ARROW: ProjectileConfig(
        speed=0.8,
        damage=15.0,
        max_lifetime_ticks=100,
        radius=0.2
    ),
    ProjectileType.MAGIC_BOLT: ProjectileConfig(
        speed=0.6,
        damage=20.0,
        max_lifetime_ticks=120,
        radius=0.25
    ),
}


class Projectile:
    """
    投射物實體

    由 Monster 發射，向指定方向飛行，擊中 Agent 造成傷害
    """

    _next_id: int = 0

    def __init__(
        self,
        position: np.ndarray,
        direction: float,  # 弧度
        projectile_type: str,
        owner_id: int,
        config: ProjectileConfig = None
    ):
        # 唯一 ID
        self.id = Projectile._next_id
        Projectile._next_id += 1

        # 位置和方向
        self.position = position.copy()
        self.direction = direction

        # 類型和配置
        self.projectile_type = projectile_type
        self.config = config or PROJECTILE_CONFIGS.get(
            projectile_type,
            ProjectileConfig()
        )

        # 所有者（發射此投射物的 Monster ID）
        self.owner_id = owner_id

        # 狀態
        self.alive = True
        self.lifetime_ticks = 0

        # 預計算速度向量
        self.velocity = np.array([
            np.cos(direction) * self.config.speed,
            np.sin(direction) * self.config.speed
        ])

    def update(self) -> bool:
        """
        更新投射物位置

        Returns:
            bool: 投射物是否仍然存活
        """
        if not self.alive:
            return False

        # 移動
        self.position += self.velocity

        # 增加存活時間
        self.lifetime_ticks += 1

        # 檢查是否超時
        if self.lifetime_ticks >= self.config.max_lifetime_ticks:
            self.alive = False
            return False

        return True

    def despawn(self):
        """銷毀投射物"""
        self.alive = False

    @property
    def damage(self) -> float:
        """獲取傷害值"""
        return self.config.damage

    @property
    def radius(self) -> float:
        """獲取碰撞半徑"""
        return self.config.radius
```

### ProjectileManager 類別

```python
# game/projectile_manager.py

from typing import List, Optional, Tuple
import numpy as np
from game.projectile import Projectile, ProjectileType, PROJECTILE_CONFIGS
from core.events import EventBus, EventType, GameEvent


class ProjectileManager:
    """
    投射物管理器

    負責：
    - 創建和追蹤所有投射物
    - 更新投射物位置
    - 碰撞檢測
    - 邊界檢測
    """

    def __init__(self, event_bus: EventBus, room_size: float = 10.0):
        self.event_bus = event_bus
        self.room_size = room_size

        # 所有活躍的投射物
        self.projectiles: List[Projectile] = []

    def spawn_projectile(
        self,
        position: np.ndarray,
        direction: float,
        projectile_type: str,
        owner_id: int
    ) -> Projectile:
        """
        創建新投射物

        Args:
            position: 起始位置
            direction: 飛行方向（弧度）
            projectile_type: 投射物類型
            owner_id: 發射者 ID

        Returns:
            新創建的 Projectile
        """
        projectile = Projectile(
            position=position,
            direction=direction,
            projectile_type=projectile_type,
            owner_id=owner_id
        )

        self.projectiles.append(projectile)

        # 發布事件
        self.event_bus.publish(GameEvent(
            EventType.PROJECTILE_SPAWNED,
            data={
                "projectile_id": projectile.id,
                "projectile_type": projectile_type,
                "position": position.tolist(),
                "direction": direction
            }
        ))

        return projectile

    def update(self, agent_position: np.ndarray, agent_radius: float = 0.5) -> List[Tuple[Projectile, float]]:
        """
        更新所有投射物

        Args:
            agent_position: Agent 的位置
            agent_radius: Agent 的碰撞半徑

        Returns:
            擊中 Agent 的投射物列表 [(projectile, damage), ...]
        """
        hits = []
        surviving = []

        for projectile in self.projectiles:
            if not projectile.alive:
                continue

            # 更新位置
            projectile.update()

            # 邊界檢測
            if self._is_out_of_bounds(projectile.position):
                projectile.despawn()
                self._publish_despawn_event(projectile, "boundary")
                continue

            # 碰撞檢測（與 Agent）
            if self._check_collision(projectile, agent_position, agent_radius):
                hits.append((projectile, projectile.damage))
                projectile.despawn()
                self._publish_hit_event(projectile)
                continue

            # 仍然存活
            if projectile.alive:
                surviving.append(projectile)

        self.projectiles = surviving
        return hits

    def _is_out_of_bounds(self, position: np.ndarray) -> bool:
        """檢查是否超出邊界"""
        return (
            position[0] < 0 or position[0] > self.room_size or
            position[1] < 0 or position[1] > self.room_size
        )

    def _check_collision(
        self,
        projectile: Projectile,
        target_position: np.ndarray,
        target_radius: float
    ) -> bool:
        """
        圓形碰撞檢測

        Args:
            projectile: 投射物
            target_position: 目標位置
            target_radius: 目標碰撞半徑

        Returns:
            是否碰撞
        """
        distance = np.linalg.norm(projectile.position - target_position)
        collision_distance = projectile.radius + target_radius
        return distance <= collision_distance

    def _publish_hit_event(self, projectile: Projectile):
        """發布擊中事件"""
        self.event_bus.publish(GameEvent(
            EventType.PROJECTILE_HIT,
            data={
                "projectile_id": projectile.id,
                "projectile_type": projectile.projectile_type,
                "damage": projectile.damage,
                "owner_id": projectile.owner_id,
                "position": projectile.position.tolist()
            }
        ))

    def _publish_despawn_event(self, projectile: Projectile, reason: str):
        """發布銷毀事件"""
        self.event_bus.publish(GameEvent(
            EventType.PROJECTILE_DESPAWNED,
            data={
                "projectile_id": projectile.id,
                "reason": reason  # "boundary", "timeout", "hit"
            }
        ))

    def get_active_projectiles(self) -> List[Projectile]:
        """獲取所有活躍投射物"""
        return [p for p in self.projectiles if p.alive]

    def get_projectiles_sorted_by_distance(
        self,
        reference_position: np.ndarray,
        max_count: int = 3
    ) -> List[Tuple[Projectile, float, float]]:
        """
        獲取按距離排序的投射物（用於特徵提取）

        Args:
            reference_position: 參考位置（Agent 位置）
            max_count: 最大返回數量

        Returns:
            [(projectile, distance, angle), ...] 按距離排序
        """
        active = self.get_active_projectiles()

        # 計算距離和角度
        projectile_data = []
        for p in active:
            delta = p.position - reference_position
            distance = np.linalg.norm(delta)
            angle = np.arctan2(delta[1], delta[0])
            projectile_data.append((p, distance, angle))

        # 按距離排序
        projectile_data.sort(key=lambda x: x[1])

        return projectile_data[:max_count]

    def clear(self):
        """清除所有投射物"""
        self.projectiles.clear()

    def reset(self):
        """重置管理器（新 Episode）"""
        self.clear()
        Projectile._next_id = 0
```

---

## 事件類型

需要在 `core/events.py` 中新增：

```python
class EventType(Enum):
    # ... 現有事件 ...

    # 投射物事件
    PROJECTILE_SPAWNED = "projectile_spawned"
    PROJECTILE_HIT = "projectile_hit"
    PROJECTILE_DESPAWNED = "projectile_despawned"
```

---

## 與 Monster 攻擊行為整合

### RangedAttackBehavior

```python
# game/behaviors/attack/ranged.py

from game.behaviors.attack.base import AttackBehavior, AttackBehaviorRegistry
from game.projectile import ProjectileType
import numpy as np


@AttackBehaviorRegistry.register
class RangedAttackBehavior(AttackBehavior):
    """
    遠程攻擊行為（弓箭）

    發射投射物攻擊 Agent
    """

    behavior_type = "ranged"

    def __init__(
        self,
        damage: float = 15.0,
        attack_range: float = 8.0,
        cooldown_ticks: int = 60,
        wind_up_ticks: int = 10,
        projectile_type: str = ProjectileType.ARROW,
        **kwargs
    ):
        super().__init__(
            damage=damage,
            attack_range=attack_range,
            cooldown_ticks=cooldown_ticks,
            wind_up_ticks=wind_up_ticks
        )
        self.projectile_type = projectile_type

    def execute_attack(
        self,
        entity,
        target_position: np.ndarray,
        projectile_manager
    ) -> bool:
        """
        執行遠程攻擊

        Returns:
            是否成功發射投射物
        """
        if not self.can_attack():
            return False

        # 計算發射方向
        direction = self._calculate_direction(entity.position, target_position)

        # 發射投射物
        projectile_manager.spawn_projectile(
            position=entity.position.copy(),
            direction=direction,
            projectile_type=self.projectile_type,
            owner_id=entity.id
        )

        # 重置冷卻
        self._start_cooldown()

        return True

    def _calculate_direction(
        self,
        from_pos: np.ndarray,
        to_pos: np.ndarray
    ) -> float:
        """計算從 from_pos 指向 to_pos 的角度"""
        delta = to_pos - from_pos
        return np.arctan2(delta[1], delta[0])

    def to_dict(self) -> dict:
        data = super().to_dict()
        data["projectile_type"] = self.projectile_type
        return data


@AttackBehaviorRegistry.register
class MagicAttackBehavior(RangedAttackBehavior):
    """
    魔法攻擊行為（法杖）

    發射魔法彈，速度較慢但傷害較高
    """

    behavior_type = "magic"

    def __init__(
        self,
        damage: float = 20.0,
        attack_range: float = 10.0,
        cooldown_ticks: int = 80,
        wind_up_ticks: int = 15,
        **kwargs
    ):
        super().__init__(
            damage=damage,
            attack_range=attack_range,
            cooldown_ticks=cooldown_ticks,
            wind_up_ticks=wind_up_ticks,
            projectile_type=ProjectileType.MAGIC_BOLT
        )
```

---

## 與 GameWorld 整合

```python
# game/world.py (修改)

class GameWorld:
    def __init__(self, event_bus: EventBus, room_size: float = 10.0):
        self.event_bus = event_bus
        self.room_size = room_size

        # ... 現有初始化 ...

        # 投射物管理器
        self.projectile_manager = ProjectileManager(event_bus, room_size)

    def tick(self):
        """世界更新"""
        # ... 現有邏輯 ...

        # 更新投射物
        if self.player:
            hits = self.projectile_manager.update(
                agent_position=self.player.position,
                agent_radius=0.5
            )

            # 處理擊中
            for projectile, damage in hits:
                self._apply_damage_to_agent(damage, projectile.owner_id)

        # ... 現有邏輯 ...

    def _apply_damage_to_agent(self, damage: float, source_id: int):
        """對 Agent 造成傷害"""
        if self.player and self.player.health:
            self.player.health.take_damage(damage)

            # 發布受傷事件
            self.event_bus.publish(GameEvent(
                EventType.DAMAGE_TAKEN,
                target_entity=self.player,
                data={
                    "damage": damage,
                    "source_id": source_id
                }
            ))

            # 檢查死亡
            if not self.player.health.is_alive:
                self.event_bus.publish(GameEvent(
                    EventType.AGENT_DIED,
                    target_entity=self.player
                ))

    def reset(self):
        """重置世界"""
        # ... 現有邏輯 ...
        self.projectile_manager.reset()
```

---

## 特徵提取整合

```python
# ai/features.py (部分)

def _extract_projectile_features(
    self,
    player_pos: np.ndarray,
    player_angle: float,
    projectile_manager: ProjectileManager,
    prev_projectile_data: List[Tuple[float, float]]
) -> Tuple[np.ndarray, List[Tuple[float, float]]]:
    """
    提取投射物特徵（15維 = 5維 × 3個）

    每個投射物：
    - [0-1] (距離, 角度)
    - [2-3] Δ距離, Δ角度
    - [4]   是否存在

    Args:
        player_pos: Agent 位置
        player_angle: Agent 朝向
        projectile_manager: 投射物管理器
        prev_projectile_data: 上一 tick 的投射物數據 [(dist, angle), ...]

    Returns:
        (features, current_projectile_data)
    """
    MAX_PROJECTILES = 3
    FEATURES_PER_PROJECTILE = 5

    features = np.zeros(MAX_PROJECTILES * FEATURES_PER_PROJECTILE)
    current_data = []

    # 獲取排序後的投射物
    projectiles = projectile_manager.get_projectiles_sorted_by_distance(
        player_pos,
        max_count=MAX_PROJECTILES
    )

    for i in range(MAX_PROJECTILES):
        base_idx = i * FEATURES_PER_PROJECTILE

        if i < len(projectiles):
            proj, distance, angle = projectiles[i]

            # 相對角度（相對於 Agent 朝向）
            relative_angle = self._normalize_angle(angle - player_angle)

            # 歸一化距離
            norm_distance = distance / self.room_size

            # 計算 delta（如果有上一 tick 的數據）
            delta_dist = 0.0
            delta_angle = 0.0
            if i < len(prev_projectile_data):
                prev_dist, prev_angle = prev_projectile_data[i]
                delta_dist = norm_distance - prev_dist
                delta_angle = self._normalize_angle(relative_angle - prev_angle)

            # 填入特徵
            features[base_idx + 0] = norm_distance
            features[base_idx + 1] = relative_angle / np.pi  # 歸一化到 [-1, 1]
            features[base_idx + 2] = delta_dist
            features[base_idx + 3] = delta_angle / np.pi
            features[base_idx + 4] = 1.0  # 存在

            current_data.append((norm_distance, relative_angle))
        else:
            # 空位填 0
            current_data.append((0.0, 0.0))

    return features, current_data

def _normalize_angle(self, angle: float) -> float:
    """將角度正規化到 [-π, π]"""
    while angle > np.pi:
        angle -= 2 * np.pi
    while angle < -np.pi:
        angle += 2 * np.pi
    return angle
```

---

## 投射物預判（進階）

Monster 的 AI 可以使用預判來提高命中率：

```python
def predict_target_position(
    target_pos: np.ndarray,
    target_velocity: np.ndarray,
    projectile_speed: float,
    source_pos: np.ndarray
) -> np.ndarray:
    """
    預判目標位置

    基於目標當前速度，計算投射物應該瞄準的位置

    Args:
        target_pos: 目標當前位置
        target_velocity: 目標速度向量
        projectile_speed: 投射物速度
        source_pos: 發射位置

    Returns:
        預判位置
    """
    # 計算到目標的距離
    distance = np.linalg.norm(target_pos - source_pos)

    # 估計飛行時間
    flight_time = distance / projectile_speed

    # 預判位置 = 當前位置 + 速度 × 時間
    predicted_pos = target_pos + target_velocity * flight_time

    return predicted_pos
```

這個預判邏輯可以在 Monster 的攻擊行為中使用，讓弓箭手和法師更有威脅性。

---

## 測試方法

```python
def test_projectile_system():
    event_bus = EventBus()
    manager = ProjectileManager(event_bus, room_size=10.0)

    # 測試創建投射物
    proj = manager.spawn_projectile(
        position=np.array([5.0, 5.0]),
        direction=0.0,  # 向右
        projectile_type=ProjectileType.ARROW,
        owner_id=1
    )

    assert proj.alive
    assert len(manager.get_active_projectiles()) == 1

    # 測試更新
    agent_pos = np.array([8.0, 5.0])
    hits = manager.update(agent_pos, agent_radius=0.5)

    # 投射物應該還在飛行
    assert len(hits) == 0
    assert proj.position[0] > 5.0  # 已經向右移動

    # 繼續更新直到擊中
    for _ in range(10):
        hits = manager.update(agent_pos, agent_radius=0.5)
        if hits:
            break

    # 應該擊中 Agent
    assert len(hits) == 1
    assert hits[0][1] == 15.0  # Arrow 傷害


def test_projectile_boundary():
    event_bus = EventBus()
    manager = ProjectileManager(event_bus, room_size=10.0)

    # 創建向邊界飛行的投射物
    manager.spawn_projectile(
        position=np.array([9.5, 5.0]),
        direction=0.0,  # 向右（會撞牆）
        projectile_type=ProjectileType.ARROW,
        owner_id=1
    )

    # 更新幾次
    for _ in range(5):
        manager.update(np.array([0.0, 0.0]), agent_radius=0.5)

    # 投射物應該已經消失
    assert len(manager.get_active_projectiles()) == 0


def test_projectile_sorting():
    event_bus = EventBus()
    manager = ProjectileManager(event_bus, room_size=10.0)

    agent_pos = np.array([5.0, 5.0])

    # 創建多個投射物
    manager.spawn_projectile(
        position=np.array([8.0, 5.0]),  # 距離 3
        direction=np.pi,
        projectile_type=ProjectileType.ARROW,
        owner_id=1
    )
    manager.spawn_projectile(
        position=np.array([6.0, 5.0]),  # 距離 1
        direction=np.pi,
        projectile_type=ProjectileType.ARROW,
        owner_id=2
    )
    manager.spawn_projectile(
        position=np.array([7.0, 5.0]),  # 距離 2
        direction=np.pi,
        projectile_type=ProjectileType.ARROW,
        owner_id=3
    )

    # 獲取排序結果
    sorted_proj = manager.get_projectiles_sorted_by_distance(agent_pos, max_count=3)

    # 應該按距離排序
    assert sorted_proj[0][0].owner_id == 2  # 最近
    assert sorted_proj[1][0].owner_id == 3  # 中間
    assert sorted_proj[2][0].owner_id == 1  # 最遠
```

---

## 效能考量

### 1. 投射物數量限制

```python
MAX_ACTIVE_PROJECTILES = 20

def spawn_projectile(self, ...):
    # 如果投射物過多，移除最舊的
    if len(self.projectiles) >= MAX_ACTIVE_PROJECTILES:
        oldest = min(self.projectiles, key=lambda p: p.id)
        oldest.despawn()
        self.projectiles.remove(oldest)

    # ... 創建新投射物 ...
```

### 2. 空間分區（可選優化）

如果投射物數量非常多，可以使用空間分區加速碰撞檢測：

```python
class SpatialHash:
    """簡單的空間哈希"""

    def __init__(self, cell_size: float = 2.0):
        self.cell_size = cell_size
        self.cells = {}

    def _get_cell(self, position: np.ndarray) -> Tuple[int, int]:
        return (
            int(position[0] // self.cell_size),
            int(position[1] // self.cell_size)
        )

    def insert(self, projectile: Projectile):
        cell = self._get_cell(projectile.position)
        if cell not in self.cells:
            self.cells[cell] = []
        self.cells[cell].append(projectile)

    def query_nearby(self, position: np.ndarray, radius: float) -> List[Projectile]:
        """查詢附近的投射物"""
        results = []
        center_cell = self._get_cell(position)

        # 檢查周圍 9 個格子
        for dx in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                cell = (center_cell[0] + dx, center_cell[1] + dy)
                if cell in self.cells:
                    results.extend(self.cells[cell])

        return results
```

對於目前的規模（最多 20 個投射物），暴力檢測已經足夠快。

---

## 與獎勵系統的整合

投射物擊中 Agent 時會觸發 `DAMAGE_TAKEN` 事件，`RewardCalculator` 已經在監聽這個事件：

```python
def _on_damage_taken(self, event: GameEvent):
    """Agent 受到傷害"""
    target = event.target_entity
    damage = event.data.get("damage", 0)

    if target and target.has_tag("player"):
        reward = self.config.damage_taken_multiplier * damage
        self._add_reward(RewardType.DAMAGE_TAKEN, reward)
```

不需要額外的投射物專用獎勵——傷害本身就是懲罰。

---

## 視覺化建議

在 `PygameRenderer` 中繪製投射物：

```python
def _draw_projectiles(self, surface, projectile_manager: ProjectileManager):
    """繪製所有投射物"""
    for proj in projectile_manager.get_active_projectiles():
        screen_pos = self._world_to_screen(proj.position)

        # 根據類型選擇顏色
        if proj.projectile_type == ProjectileType.ARROW:
            color = (139, 69, 19)  # 棕色
        elif proj.projectile_type == ProjectileType.MAGIC_BOLT:
            color = (138, 43, 226)  # 紫色
        else:
            color = (255, 255, 255)  # 白色

        # 繪製圓形
        radius = int(proj.radius * self.scale)
        pygame.draw.circle(surface, color, screen_pos, max(radius, 3))

        # 繪製方向線
        end_pos = (
            screen_pos[0] + int(np.cos(proj.direction) * 10),
            screen_pos[1] - int(np.sin(proj.direction) * 10)
        )
        pygame.draw.line(surface, color, screen_pos, end_pos, 2)
```

# 技能系統設計文檔

## 概述

本文檔詳細說明 Agent（Boss）的 8 個技能的實作細節，包含程式碼架構、類別設計、以及每個技能的具體實現邏輯。

---

## 技能總覽

| ID  | 技能名稱 | 範圍類型   | 可移動 | 需要瞄準 | Actor 數量 |
| --- | ---- | ------ | --- | ---- | -------- |
| 1   | 外圈刮  | 環形 AOE | ✅   | ❌    | 0        |
| 2   | 飛彈   | 直線投射物  | ❌   | ✅    | 1        |
| 3   | 鐵錘   | 扇形/距離  | ✅   | ✅    | 1        |
| 4   | 閃現   | 位移     | -   | ✅    | 2        |
| 5   | 靈魂爪  | 長方形拉人  | ❌   | ✅    | 1        |
| 6   | 靈魂掌  | 長方形推人  | ❌   | ✅    | 1        |
| 7   | 血池   | 原地 AOE | ✅   | ❌    | 0        |
| 8   | 召喚血包 | 無傷害    | ❌   | ❌    | 0        |

**連續 Actor 總數：6 個**

---

## 程式碼架構

### 檔案結構

```
game/
├── skills/
│   ├── __init__.py
│   ├── base.py              # SkillDefinition 基類
│   ├── registry.py          # SkillRegistry 技能註冊表
│   ├── executor.py          # SkillExecutor 技能執行器
│   ├── cooldown.py          # CooldownManager CD 管理
│   └── implementations/
│       ├── __init__.py
│       ├── outer_slash.py   # 外圈刮
│       ├── missile.py       # 飛彈
│       ├── hammer.py        # 鐵錘
│       ├── dash.py          # 閃現
│       ├── soul_claw.py     # 靈魂爪
│       ├── soul_palm.py     # 靈魂掌
│       ├── blood_pool.py    # 血池
│       └── summon_pack.py   # 召喚血包
```

### 類別關係圖

```
SkillDefinition (ABC)
    │
    ├── OuterSlashSkill      (外圈刮)
    ├── MissileSkill         (飛彈)
    ├── HammerSkill          (鐵錘)
    ├── DashSkill            (閃現)
    ├── SoulClawSkill        (靈魂爪)
    ├── SoulPalmSkill        (靈魂掌)
    ├── BloodPoolSkill       (血池)
    └── SummonPackSkill      (召喚血包)

SkillRegistry
    └── 管理所有技能定義

CooldownManager
    ├── individual_cds: Dict[skill_id, remaining_ticks]
    └── shared_cd: remaining_ticks

SkillExecutor
    ├── 處理技能施放流程
    ├── 前搖計時
    ├── 範圍判定
    └── 傷害計算
```

---

## 基類設計

### SkillDefinition

```python
# game/skills/base.py

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Optional, Tuple
from enum import Enum
import numpy as np

class SkillType(Enum):
    """技能類型枚舉"""
    INSTANT = "instant"           # 即時生效
    PROJECTILE = "projectile"     # 投射物
    CHANNEL = "channel"           # 持續施法
    DASH = "dash"                 # 位移技能

@dataclass
class SkillDefinition(ABC):
    """
    技能定義基類

    所有技能必須繼承此類並實現 execute 方法
    """
    skill_id: int                    # 技能 ID (1-8)
    name: str                        # 技能名稱
    skill_type: SkillType            # 技能類型

    # 冷卻相關
    cooldown_ticks: int              # 獨立 CD (tick 數)

    # 前搖相關
    wind_up_ticks: int               # 前搖時間 (tick 數)
    can_move_during_wind_up: bool    # 前搖期間是否可移動

    # 瞄準相關
    requires_aim: bool               # 是否需要瞄準
    aim_actor_count: int = 0         # 需要幾個瞄準 Actor

    # 傷害相關
    base_damage: float = 0.0         # 基礎傷害

    @abstractmethod
    def execute(
        self,
        caster_pos: np.ndarray,
        caster_angle: float,
        aim_values: List[float],      # 瞄準 Actor 的輸出值
        targets: List['Entity'],
        world: 'GameWorld'
    ) -> 'SkillResult':
        """
        執行技能

        Args:
            caster_pos: 施法者位置
            caster_angle: 施法者朝向
            aim_values: 瞄準值列表 (長度 = aim_actor_count)
            targets: 潛在目標列表
            world: 遊戲世界引用

        Returns:
            SkillResult 包含命中目標、傷害等資訊
        """
        pass

    @abstractmethod
    def get_hit_area(
        self,
        caster_pos: np.ndarray,
        caster_angle: float,
        aim_values: List[float]
    ) -> 'HitArea':
        """
        獲取技能命中區域（用於視覺化前搖提示）
        """
        pass


@dataclass
class SkillResult:
    """技能執行結果"""
    skill_id: int
    hit_targets: List['Entity']       # 命中的目標
    damage_dealt: Dict['Entity', float]  # 每個目標受到的傷害
    effects: List[str]                # 特殊效果 (如位移)
    projectile_spawned: Optional['Projectile'] = None  # 生成的投射物
```

### CooldownManager

```python
# game/skills/cooldown.py

class CooldownManager:
    """
    技能冷卻管理器

    管理獨立 CD 和共享 CD
    """

    SHARED_CD_TICKS = 8  # 1.5秒 ≈ 8 ticks (假設每秒約5 tick)

    def __init__(self, skill_count: int = 8):
        self.skill_count = skill_count
        self.individual_cds: Dict[int, int] = {i: 0 for i in range(1, skill_count + 1)}
        self.shared_cd: int = 0

    def tick(self) -> None:
        """每個 tick 調用，減少所有 CD"""
        # 減少共享 CD
        if self.shared_cd > 0:
            self.shared_cd -= 1

        # 減少所有獨立 CD
        for skill_id in self.individual_cds:
            if self.individual_cds[skill_id] > 0:
                self.individual_cds[skill_id] -= 1

    def is_ready(self, skill_id: int) -> bool:
        """檢查技能是否可以施放"""
        return (
            self.shared_cd == 0 and
            self.individual_cds.get(skill_id, 0) == 0
        )

    def use_skill(self, skill_id: int, individual_cd: int) -> None:
        """使用技能，觸發 CD"""
        self.shared_cd = self.SHARED_CD_TICKS
        self.individual_cds[skill_id] = individual_cd

    def get_cd_features(self) -> np.ndarray:
        """
        獲取 CD 特徵向量 (用於觀測空間)

        Returns:
            [shared_cd_ratio, skill1_cd_ratio, skill2_cd_ratio, ...]
            所有值歸一化到 0-1，0 表示已就緒
        """
        features = [self.shared_cd / self.SHARED_CD_TICKS]

        # 假設最大獨立 CD 為 40 ticks (8秒)
        MAX_INDIVIDUAL_CD = 40
        for skill_id in range(1, self.skill_count + 1):
            cd = self.individual_cds.get(skill_id, 0)
            features.append(cd / MAX_INDIVIDUAL_CD)

        return np.array(features)
```

---

## 各技能詳細設計

### 1. 外圈刮 (Outer Slash)

**概念**：環形 AOE，只打 3.0 ≤ 距離 ≤ 4.5 的目標

**參數**：

```python
skill_id = 1
cooldown_ticks = 30        # 約 6 秒
wind_up_ticks = 10         # 約 2 秒前搖
can_move_during_wind_up = True
requires_aim = False
base_damage = 30.0
inner_radius = 3.0
outer_radius = 4.5
```

**實作**：

```python
# game/skills/implementations/outer_slash.py

@dataclass
class OuterSlashSkill(SkillDefinition):
    inner_radius: float = 3.0
    outer_radius: float = 4.5

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        hit_targets = []
        damage_dealt = {}

        for target in targets:
            if not target.is_alive:
                continue

            target_pos = target.position.as_array()
            distance = np.linalg.norm(target_pos - caster_pos)

            # 檢查是否在環形範圍內
            if self.inner_radius <= distance <= self.outer_radius:
                hit_targets.append(target)
                damage_dealt[target] = self.base_damage

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=hit_targets,
            damage_dealt=damage_dealt,
            effects=[]
        )

    def get_hit_area(self, caster_pos, caster_angle, aim_values):
        return RingHitArea(
            center=caster_pos,
            inner_radius=self.inner_radius,
            outer_radius=self.outer_radius
        )
```

**Agent 策略提示**：

- 需要走位到與敵人保持 3-4.5 距離
- 可以邊移動邊施放，調整位置
- 多個敵人聚集時效益最大

---

### 2. 飛彈 (Missile)

**概念**：直線投射物，有飛行時間，需要預判

**參數**：

```python
skill_id = 2
cooldown_ticks = 25        # 約 5 秒
wind_up_ticks = 5          # 約 1 秒前搖
can_move_during_wind_up = False
requires_aim = True
aim_actor_count = 1        # aim_actor_missile
base_damage = 40.0
projectile_speed = 1.5     # 每 tick 移動距離
projectile_radius = 0.5    # 碰撞半徑
max_range = 15.0           # 最大射程
```

**瞄準 Actor 輸出**：

- `aim_values[0]`：角度偏移 (弧度)，範圍 [-π, π]
- 最終發射角度 = `caster_angle + aim_values[0]`

**實作**：

```python
# game/skills/implementations/missile.py

@dataclass
class MissileSkill(SkillDefinition):
    projectile_speed: float = 1.5
    projectile_radius: float = 0.5
    max_range: float = 15.0

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        # 計算發射角度
        aim_offset = aim_values[0] if aim_values else 0.0
        fire_angle = caster_angle + aim_offset

        # 計算發射方向
        direction = np.array([np.cos(fire_angle), np.sin(fire_angle)])

        # 創建投射物 Entity
        projectile = world.spawn_projectile(
            position=caster_pos.copy(),
            velocity=direction * self.projectile_speed,
            damage=self.base_damage,
            owner=None,  # Agent 的投射物
            radius=self.projectile_radius,
            max_distance=self.max_range
        )

        # 投射物會在之後的 tick 中檢測碰撞
        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=[],
            damage_dealt={},
            effects=["projectile_spawned"],
            projectile_spawned=projectile
        )
```

**Agent 策略提示**：

- 需要預判敵人移動方向
- 施放時無法移動，需要選擇安全時機
- 適合遠距離風箏

---

### 3. 鐵錘 (Hammer)

**概念**：長條形範圍，末端傷害更高

**參數**：

```python
skill_id = 3
cooldown_ticks = 35        # 約 7 秒
wind_up_ticks = 15         # 約 3 秒前搖
can_move_during_wind_up = True
requires_aim = True
aim_actor_count = 1        # aim_actor_hammer
base_damage = 25.0         # 近端傷害
tip_damage = 50.0          # 末端傷害
min_range = 1.0
max_range = 5.0
tip_range_start = 4.0      # 末端範圍起點
```

**傷害計算**：

```
if distance < tip_range_start:
    damage = base_damage
else:
    damage = tip_damage
```

**實作**：

```python
# game/skills/implementations/hammer.py

@dataclass
class HammerSkill(SkillDefinition):
    tip_damage: float = 50.0
    min_range: float = 1.0
    max_range: float = 5.0
    tip_range_start: float = 4.0
    angle_width: float = 0.6

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        aim_offset = aim_values[0] if aim_values else 0.0
        hammer_angle = caster_angle + aim_offset

        hit_targets = []
        damage_dealt = {}

        for target in targets:
            if not target.is_alive:
                continue

            target_pos = target.position.as_array()
            diff = target_pos - caster_pos
            distance = np.linalg.norm(diff)

            # 檢查距離
            if not (self.min_range <= distance <= self.max_range):
                continue

            # 檢查角度
            angle_to_target = np.arctan2(diff[1], diff[0])
            angle_diff = self._normalize_angle(angle_to_target - hammer_angle)

            if abs(angle_diff) > self.angle_width / 2:
                continue

            # 計算傷害（末端加成）
            if distance >= self.tip_range_start:
                damage = self.tip_damage
            else:
                damage = self.base_damage

            hit_targets.append(target)
            damage_dealt[target] = damage

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=hit_targets,
            damage_dealt=damage_dealt,
            effects=[]
        )

    def _normalize_angle(self, angle):
        """將角度歸一化到 [-π, π]"""
        while angle > np.pi:
            angle -= 2 * np.pi
        while angle < -np.pi:
            angle += 2 * np.pi
        return angle
```

**Agent 策略提示**：

- 風險收益權衡：追求末端高傷 vs 確保命中
- 可以邊移動邊調整瞄準
- 適合對付逃跑的敵人

---

### 4. 閃現 (Dash)

**概念**：固定距離位移，需要選擇方向和朝向

**參數**：

```python
skill_id = 4
cooldown_ticks = 40        # 約 8 秒
wind_up_ticks = 0          # 無前搖
can_move_during_wind_up = False  # N/A
requires_aim = True
aim_actor_count = 2        # aim_actor_dash_direction, aim_actor_dash_facing
dash_distance = 3.0        # 閃現距離
```

**瞄準 Actor 輸出**：

- `aim_values[0]`：閃現方向角度（相對於當前朝向）
- `aim_values[1]`：閃現後的朝向角度（相對於當前朝向）

**實作**：

```python
# game/skills/implementations/dash.py

@dataclass
class DashSkill(SkillDefinition):
    dash_distance: float = 3.0

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        # 解析瞄準值
        direction_offset = aim_values[0] if len(aim_values) > 0 else 0.0
        facing_offset = aim_values[1] if len(aim_values) > 1 else 0.0

        # 計算閃現方向
        dash_angle = caster_angle + direction_offset
        dash_vector = np.array([
            np.cos(dash_angle) * self.dash_distance,
            np.sin(dash_angle) * self.dash_distance
        ])

        # 計算新位置（需要邊界檢查）
        new_pos = caster_pos + dash_vector
        new_pos = world.clamp_position(new_pos)  # 確保不超出邊界

        # 計算新朝向
        new_facing = caster_angle + facing_offset

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=[],
            damage_dealt={},
            effects=[
                f"teleport:{new_pos[0]},{new_pos[1]}",
                f"set_facing:{new_facing}"
            ]
        )
```

**Agent 策略提示**：

- 閃現進場：衝進敵人群 + 立刻放外圈刮/血池
- 閃現逃跑：離開危險區域
- 閃現後朝向很重要：決定下一個技能的瞄準起點

---

### 5. 靈魂爪 (Soul Claw)

**概念**：長方形範圍，將敵人拉向自己

**參數**：

```python
skill_id = 5
cooldown_ticks = 35        # 約 7 秒
wind_up_ticks = 8          # 約 1.6 秒前搖
can_move_during_wind_up = False
requires_aim = True
aim_actor_count = 1        # aim_actor_claw
base_damage = 20.0
range_length = 6.0         # 長方形長度
range_width = 2.0          # 長方形寬度
pull_distance = 3.0        # 拉動距離
```

**實作**：

```python
# game/skills/implementations/soul_claw.py

@dataclass
class SoulClawSkill(SkillDefinition):
    range_length: float = 6.0
    range_width: float = 2.0
    pull_distance: float = 3.0

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        aim_offset = aim_values[0] if aim_values else 0.0
        claw_angle = caster_angle + aim_offset

        hit_targets = []
        damage_dealt = {}
        effects = []

        # 計算長方形的方向向量
        forward = np.array([np.cos(claw_angle), np.sin(claw_angle)])
        right = np.array([np.sin(claw_angle), -np.cos(claw_angle)])

        for target in targets:
            if not target.is_alive:
                continue

            target_pos = target.position.as_array()
            diff = target_pos - caster_pos

            # 投影到長方形座標系
            forward_dist = np.dot(diff, forward)
            right_dist = np.dot(diff, right)

            # 檢查是否在長方形內
            if (0 < forward_dist <= self.range_length and
                abs(right_dist) <= self.range_width / 2):

                hit_targets.append(target)
                damage_dealt[target] = self.base_damage

                # 計算拉動後的位置（向施法者方向拉）
                pull_vector = -forward * self.pull_distance
                new_target_pos = target_pos + pull_vector

                # 確保不會拉到施法者身上
                if np.linalg.norm(new_target_pos - caster_pos) < 1.0:
                    new_target_pos = caster_pos + forward * 1.0

                effects.append(f"pull:{target.id}:{new_target_pos[0]},{new_target_pos[1]}")

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=hit_targets,
            damage_dealt=damage_dealt,
            effects=effects
        )
```

**Agent 策略提示**：

- 將分散的敵人拉到一起 → 外圈刮 combo
- 將遠程敵人拉近，進入近戰範圍
- 不能移動，需要選擇安全時機

---

### 6. 靈魂掌 (Soul Palm)

**概念**：長方形範圍，將敵人推離自己（靈魂爪的對偶）

**參數**：

```python
skill_id = 6
cooldown_ticks = 35        # 約 7 秒
wind_up_ticks = 8          # 約 1.6 秒前搖
can_move_during_wind_up = False
requires_aim = True
aim_actor_count = 1        # aim_actor_palm
base_damage = 20.0
range_length = 6.0
range_width = 2.0
push_distance = 3.0        # 推動距離
```

**實作**：

```python
# game/skills/implementations/soul_palm.py

@dataclass
class SoulPalmSkill(SkillDefinition):
    range_length: float = 6.0
    range_width: float = 2.0
    push_distance: float = 3.0

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        aim_offset = aim_values[0] if aim_values else 0.0
        palm_angle = caster_angle + aim_offset

        hit_targets = []
        damage_dealt = {}
        effects = []

        forward = np.array([np.cos(palm_angle), np.sin(palm_angle)])
        right = np.array([np.sin(palm_angle), -np.cos(palm_angle)])

        for target in targets:
            if not target.is_alive:
                continue

            target_pos = target.position.as_array()
            diff = target_pos - caster_pos

            forward_dist = np.dot(diff, forward)
            right_dist = np.dot(diff, right)

            if (0 < forward_dist <= self.range_length and
                abs(right_dist) <= self.range_width / 2):

                hit_targets.append(target)
                damage_dealt[target] = self.base_damage

                # 計算推動後的位置（向遠離施法者方向推）
                push_vector = forward * self.push_distance
                new_target_pos = target_pos + push_vector
                new_target_pos = world.clamp_position(new_target_pos)

                effects.append(f"push:{target.id}:{new_target_pos[0]},{new_target_pos[1]}")

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=hit_targets,
            damage_dealt=damage_dealt,
            effects=effects
        )
```

**Agent 策略提示**：

- 將敵人推到牆角 → 限制敵人走位
- 創造空間逃脫包圍
- 與靈魂爪配合：拉近 → 打 → 推開

---

### 7. 血池 (Blood Pool)

**概念**：沉入血池無敵，蹦出時 AOE 傷害。沉入血池時無法施放其他技能。

**參數**：

```python
skill_id = 7
cooldown_ticks = 40        # 約 8 秒
wind_up_ticks = 0          # 立即沉入
pool_duration_ticks = 15   # 在血池中的時間（約 3 秒）
can_move_during_wind_up = True  # 血池中可移動
requires_aim = False
emerge_damage = 35.0       # 蹦出傷害
emerge_radius = 2.5        # 蹦出傷害半徑
```

**狀態機**：

```
NORMAL → (施放) → IN_POOL → (時間到) → EMERGE → NORMAL
           │                    │
           └── 無敵、可移動 ──┘
```

**實作**：

```python
# game/skills/implementations/blood_pool.py

class BloodPoolState(Enum):
    INACTIVE = "inactive"
    IN_POOL = "in_pool"
    EMERGING = "emerging"

@dataclass
class BloodPoolSkill(SkillDefinition):
    pool_duration_ticks: int = 15
    emerge_damage: float = 35.0
    emerge_radius: float = 2.5

    # 狀態追蹤（需要在 Entity 或單獨的狀態管理器中維護）

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        # 施放時立即進入血池狀態
        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=[],
            damage_dealt={},
            effects=["enter_blood_pool"]
        )

    def on_emerge(self, caster_pos, targets, world):
        """蹦出時調用"""
        hit_targets = []
        damage_dealt = {}

        for target in targets:
            if not target.is_alive:
                continue

            distance = np.linalg.norm(target.position.as_array() - caster_pos)

            if distance <= self.emerge_radius:
                hit_targets.append(target)
                damage_dealt[target] = self.emerge_damage

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=hit_targets,
            damage_dealt=damage_dealt,
            effects=["exit_blood_pool"]
        )
```

**Agent 策略提示**：

- 被圍毆時沉入血池躲避
- 血池中移動到敵人聚集處
- 蹦出時造成範圍傷害
- 攻防一體的核心技能

---

### 8. 召喚血包 (Summon Blood Pack)

**概念**：在場地隨機位置生成 3 個血包

**參數**：

```python
skill_id = 8
cooldown_ticks = 50        # 約 10 秒
wind_up_ticks = 10         # 約 2 秒前搖
can_move_during_wind_up = False  # 施放時無法移動（高風險）
requires_aim = False
pack_count = 3
heal_amount_per_pack = 30.0
```

**實作**：

```python
# game/skills/implementations/summon_pack.py

@dataclass
class SummonPackSkill(SkillDefinition):
    pack_count: int = 3
    heal_amount_per_pack: float = 30.0

    def execute(self, caster_pos, caster_angle, aim_values, targets, world):
        spawned_packs = []

        for _ in range(self.pack_count):
            # 隨機位置（避開牆壁）
            pos = world.room.random_position(margin=1.5)

            pack = world.spawn_blood_pack(pos, self.heal_amount_per_pack)
            spawned_packs.append(pack)

        return SkillResult(
            skill_id=self.skill_id,
            hit_targets=[],
            damage_dealt={},
            effects=[f"spawn_blood_pack:{p.id}" for p in spawned_packs]
        )
```

**Agent 策略提示**：

- 低血量時使用
- 施放時無法移動，需要安全時機
- 放完後要規劃吃血包路線
- 召喚有 +3 獎勵，鼓勵使用

---

## 技能執行器

```python
# game/skills/executor.py

class SkillExecutor:
    """
    技能執行器

    處理技能施放的完整流程：
    1. CD 檢查
    2. 開始前搖
    3. 前搖期間處理（可能被打斷？）
    4. 前搖結束，執行技能
    5. 觸發 CD
    """

    def __init__(self, event_bus: EventBus, skill_registry: SkillRegistry):
        self.event_bus = event_bus
        self.skill_registry = skill_registry
        self.cooldown_manager = CooldownManager(skill_count=8)

        # 當前施法狀態
        self.current_skill_id: Optional[int] = None
        self.wind_up_remaining: int = 0
        self.aim_values: List[float] = []

    def can_cast(self, skill_id: int) -> bool:
        """檢查技能是否可以施放"""
        return (
            self.current_skill_id is None and  # 沒有在施法
            self.cooldown_manager.is_ready(skill_id)
        )

    def start_cast(self, skill_id: int, aim_values: List[float]) -> bool:
        """
        開始施放技能

        Returns:
            是否成功開始施放
        """
        if not self.can_cast(skill_id):
            return False

        skill = self.skill_registry.get(skill_id)

        self.current_skill_id = skill_id
        self.wind_up_remaining = skill.wind_up_ticks
        self.aim_values = aim_values

        # 發布開始施法事件
        self.event_bus.publish(GameEvent(
            EventType.SKILL_CAST_START,
            data={
                'skill_id': skill_id,
                'wind_up_ticks': skill.wind_up_ticks
            }
        ))

        # 如果沒有前搖，立即執行
        if self.wind_up_remaining == 0:
            self._execute_skill()

        return True

    def tick(self, caster: Entity, targets: List[Entity], world: GameWorld):
        """每個 tick 調用"""
        # 更新 CD
        self.cooldown_manager.tick()

        # 如果正在施法
        if self.current_skill_id is not None:
            self.wind_up_remaining -= 1

            if self.wind_up_remaining <= 0:
                self._execute_skill(caster, targets, world)

    def _execute_skill(self, caster: Entity, targets: List[Entity], world: GameWorld):
        """執行技能"""
        skill = self.skill_registry.get(self.current_skill_id)

        result = skill.execute(
            caster_pos=caster.position.as_array(),
            caster_angle=caster.position.angle,
            aim_values=self.aim_values,
            targets=targets,
            world=world
        )

        # 處理結果
        self._process_result(result, caster, targets, world)

        # 觸發 CD
        self.cooldown_manager.use_skill(
            self.current_skill_id,
            skill.cooldown_ticks
        )

        # 重置狀態
        self.current_skill_id = None
        self.aim_values = []

    def _process_result(self, result: SkillResult, caster, targets, world):
        """處理技能結果"""
        # 造成傷害
        for target, damage in result.damage_dealt.items():
            if target.has_health():
                target.health.damage(damage)

                # 發布傷害事件
                self.event_bus.publish(GameEvent(
                    EventType.DAMAGE_DEALT,
                    source_entity=caster,
                    target_entity=target,
                    data={'damage': damage, 'skill_id': result.skill_id}
                ))

                # 檢查擊殺
                if not target.health.is_alive:
                    target.despawn()
                    self.event_bus.publish(GameEvent(
                        EventType.ENTITY_KILLED,
                        source_entity=caster,
                        target_entity=target,
                        data={'skill_id': result.skill_id}
                    ))

        # 處理特殊效果
        for effect in result.effects:
            self._process_effect(effect, caster, targets, world)

    def _process_effect(self, effect: str, caster, targets, world):
        """處理特殊效果"""
        if effect.startswith("teleport:"):
            # 閃現
            _, coords = effect.split(":", 1)
            x, y = map(float, coords.split(","))
            caster.position.x = x
            caster.position.y = y

        elif effect.startswith("set_facing:"):
            # 設定朝向
            _, angle = effect.split(":", 1)
            caster.position.angle = float(angle)

        elif effect.startswith("pull:") or effect.startswith("push:"):
            # 拉/推效果
            parts = effect.split(":")
            target_id = int(parts[1])
            x, y = map(float, parts[2].split(","))

            for target in targets:
                if target.id == target_id:
                    target.position.x = x
                    target.position.y = y
                    break

        elif effect == "enter_blood_pool":
            caster.set_component("blood_pool_state", BloodPoolState.IN_POOL)

        elif effect == "exit_blood_pool":
            caster.set_component("blood_pool_state", BloodPoolState.INACTIVE)

    def is_casting(self) -> bool:
        """是否正在施法"""
        return self.current_skill_id is not None

    def can_move_while_casting(self) -> bool:
        """施法期間是否可以移動"""
        if self.current_skill_id is None:
            return True
        skill = self.skill_registry.get(self.current_skill_id)
        return skill.can_move_during_wind_up
```

---

## 與 Agent 的整合

### 動作空間修改

```python
# ai/agent.py 中的修改

class HybridPPOAgent:
    def __init__(self, n_features, ...):
        # 離散動作：11 個選項
        # 0: MOVE_FORWARD
        # 1: TURN_LEFT
        # 2: TURN_RIGHT
        # 3-10: SKILL_1 到 SKILL_8
        self.n_discrete_actions = 11

        # 連續 Actor：6 個
        # 0: aim_actor_missile (飛彈)
        # 1: aim_actor_hammer (鐵錘)
        # 2: aim_actor_dash_direction (閃現方向)
        # 3: aim_actor_dash_facing (閃現朝向)
        # 4: aim_actor_claw (靈魂爪)
        # 5: aim_actor_palm (靈魂掌)
        self.n_aim_actors = 6

        # 權重
        self.w_actor_discrete = np.random.randn(11, n_features) * 0.01
        self.w_aim_actors = [
            np.random.randn(n_features) * 0.01  # aim_actor_missile
            for _ in range(6)
        ]
```

### 技能與 Actor 的映射

```python
SKILL_AIM_MAPPING = {
    # skill_id: [aim_actor_indices]
    1: [],           # 外圈刮 - 無需瞄準
    2: [0],          # 飛彈 - aim_actor_missile
    3: [1],          # 鐵錘 - aim_actor_hammer
    4: [2, 3],       # 閃現 - dash_direction, dash_facing
    5: [4],          # 靈魂爪 - aim_actor_claw
    6: [5],          # 靈魂掌 - aim_actor_palm
    7: [],           # 血池 - 無需瞄準
    8: [],           # 召喚血包 - 無需瞄準
}
```

---

## 測試計畫

### 單元測試

1. **技能範圍判定測試**
   
   - 外圈刮的環形範圍
   - 鐵錘的扇形範圍
   - 靈魂爪/掌的長方形範圍

2. **CD 系統測試**
   
   - 獨立 CD 正確計時
   - 共享 CD 阻止連招

3. **位移效果測試**
   
   - 閃現的位置和朝向
   - 靈魂爪的拉動
   - 靈魂掌的推動

### 整合測試

1. **技能連招測試**
   
   - 靈魂爪 → 外圈刮 combo
   - 閃現 → 血池 combo

2. **與 Agent 的整合**
   
   - 離散動作正確觸發技能
   - 瞄準 Actor 正確影響技能方向

---

## 實作優先級

1. **Phase 1**: 基礎架構
   
   - SkillDefinition 基類
   - SkillRegistry
   - CooldownManager
   - SkillExecutor 框架

2. **Phase 2**: 簡單技能
   
   - 外圈刮（純距離判定）
   - 召喚血包（無傷害）

3. **Phase 3**: 瞄準技能
   
   - 飛彈（直線投射物）
   - 鐵錘（扇形範圍）

4. **Phase 4**: 位移技能
   
   - 閃現
   - 血池

5. **Phase 5**: 控制技能

   - 靈魂爪
   - 靈魂掌

---

## 開發者模式操作

開發者模式（`python main.py --dev`）用於手動控制玩家來 debug 遊戲邏輯。

### 設計理念

- **時間靜止**：除非有輸入，遊戲世界完全靜止，給人類充足時間思考
- **架構一致**：`鍵盤 → Player → World`，與 `Agent → Player → World` 共用 Player 層
- **非法操作在 Player 層擋下**：例如 wind-up 期間無法移動，無論輸入來自 Agent 還是鍵盤

### 基本操作

| 按鍵 | 動作 |
|------|------|
| W | 前進 |
| A | 左轉 |
| D | 右轉 |
| P | 空過（跳過一個 tick）|
| 1-8 | 施放對應技能 |
| R | 重置世界 |
| ESC | 離開 |

**滑鼠**：控制瞄準方向

### 多瞄準器操作（連續點擊方案）

對於需要多個瞄準值的技能，使用「連續點擊」方案：

以閃現（2 個瞄準器）為例：
1. 按 `4`（閃現鍵）→ 進入瞄準模式，遊戲靜止
2. 滑鼠移動到想要的閃現方向，左鍵點擊 → 設定 `aim_1`（閃現方向）
3. 滑鼠移動到想要的閃現後朝向，左鍵點擊 → 設定 `aim_2`（閃現後朝向）
4. 技能自動執行，遊戲推進一個 tick

### 各技能操作流程

| 技能 | 瞄準數 | 操作流程 |
|------|--------|----------|
| 外圈刮 | 0 | 按 1 → 直接執行 |
| 飛彈 | 1 | 按 2 → 點擊設定方向 → 執行 |
| 鐵錘 | 1 | 按 3 → 點擊設定方向 → 執行 |
| 閃現 | 2 | 按 4 → 點擊設定方向 → 點擊設定朝向 → 執行 |
| 靈魂爪 | 1 | 按 5 → 點擊設定方向 → 執行 |
| 靈魂掌 | 1 | 按 6 → 點擊設定方向 → 執行 |
| 血池 | 0 | 按 7 → 直接執行 |
| 召喚血包 | 0 | 按 8 → 直接執行 |

### 實作備註

當實作多瞄準技能時，需在 `dev_mode.py` 中新增：

```python
class AimingState:
    """追蹤多瞄準器的輸入狀態"""
    skill_id: Optional[str]          # 正在瞄準的技能
    required_aims: int               # 需要的瞄準數量
    collected_aims: List[float]      # 已收集的瞄準值
```

並修改 `_wait_for_input` 區分：
- **正常模式**：等待鍵盤輸入
- **瞄準模式**：等待滑鼠點擊，每次點擊收集一個瞄準值

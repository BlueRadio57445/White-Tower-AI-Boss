# 獎勵系統設計文檔

## 概述

本文檔詳細說明獎勵計算的實作細節，包含事件監聽、獎勵觸發條件、以及與訓練循環的整合。

---

## 獎勵定義

| 類別 | 事件 | 獎勵值 | 說明 |
|------|------|--------|------|
| 基礎 | TICK | -0.01 | 時間壓力 |
| 基礎 | HIT_WALL | -2.0 | 撞牆懲罰 |
| 戰鬥 | DAMAGE_DEALT | +1.0 × damage | 造成傷害 |
| 戰鬥 | DAMAGE_TAKEN | -1.0 × damage | 受到傷害 |
| 戰鬥 | HEAL | +1.0 × heal_amount | 回血 |
| 事件 | KILL_ENEMY | +20.0 | 擊殺敵人 |
| 事件 | SUMMON_BLOOD_PACK | +3.0 | 召喚血包 |
| 事件 | AGENT_DIED | -200.0 | Agent 死亡 |
| 事件 | ALL_ENEMIES_DEAD | +300.0 | 殲滅所有敵人 |

---

## 程式碼架構

### 檔案結構

```
ai/
├── reward.py                # RewardCalculator 主類
```

### 類別設計

```python
# ai/reward.py

from dataclasses import dataclass
from enum import Enum
from typing import Dict, List
from core.events import EventBus, EventType, GameEvent


class RewardType(Enum):
    """獎勵類型枚舉"""
    TICK = "tick"
    HIT_WALL = "hit_wall"
    DAMAGE_DEALT = "damage_dealt"
    DAMAGE_TAKEN = "damage_taken"
    HEAL = "heal"
    KILL_ENEMY = "kill_enemy"
    SUMMON_BLOOD_PACK = "summon_blood_pack"
    AGENT_DIED = "agent_died"
    ALL_ENEMIES_DEAD = "all_enemies_dead"


@dataclass
class RewardConfig:
    """獎勵配置"""
    tick: float = -0.01
    hit_wall: float = -2.0
    damage_dealt_multiplier: float = 1.0
    damage_taken_multiplier: float = -1.0
    heal_multiplier: float = 1.0
    kill_enemy: float = 20.0
    summon_blood_pack: float = 3.0
    agent_died: float = -200.0
    all_enemies_dead: float = 300.0


class RewardCalculator:
    """
    獎勵計算器

    監聽遊戲事件並累積獎勵
    """

    def __init__(self, event_bus: EventBus, config: RewardConfig = None):
        self.event_bus = event_bus
        self.config = config or RewardConfig()

        # 當前 tick 的累積獎勵
        self._accumulated_reward: float = 0.0

        # 獎勵分解（用於調試和分析）
        self._reward_breakdown: Dict[RewardType, float] = {}

        # Episode 結束標誌
        self._episode_done: bool = False
        self._win: bool = False

        # 註冊事件監聽
        self._register_listeners()

    def _register_listeners(self):
        """註冊所有事件監聽器"""
        self.event_bus.subscribe(EventType.TICK, self._on_tick)
        self.event_bus.subscribe(EventType.ENTITY_HIT_WALL, self._on_hit_wall)
        self.event_bus.subscribe(EventType.DAMAGE_DEALT, self._on_damage_dealt)
        self.event_bus.subscribe(EventType.DAMAGE_TAKEN, self._on_damage_taken)
        self.event_bus.subscribe(EventType.HEAL, self._on_heal)
        self.event_bus.subscribe(EventType.ENTITY_KILLED, self._on_entity_killed)
        self.event_bus.subscribe(EventType.SKILL_CAST_COMPLETE, self._on_skill_cast)
        self.event_bus.subscribe(EventType.AGENT_DIED, self._on_agent_died)

    def _add_reward(self, reward_type: RewardType, value: float):
        """添加獎勵並記錄分解"""
        self._accumulated_reward += value

        if reward_type not in self._reward_breakdown:
            self._reward_breakdown[reward_type] = 0.0
        self._reward_breakdown[reward_type] += value

    # ==================== 事件處理器 ====================

    def _on_tick(self, event: GameEvent):
        """每個 tick 的基礎懲罰"""
        self._add_reward(RewardType.TICK, self.config.tick)

    def _on_hit_wall(self, event: GameEvent):
        """撞牆懲罰（只對 Agent）"""
        entity = event.source_entity
        if entity and entity.has_tag("player"):
            self._add_reward(RewardType.HIT_WALL, self.config.hit_wall)

    def _on_damage_dealt(self, event: GameEvent):
        """Agent 對敵人造成傷害"""
        source = event.source_entity
        target = event.target_entity
        damage = event.data.get("damage", 0)

        # 只有 Agent 造成的傷害才獎勵
        if source and source.has_tag("player") and target and target.has_tag("monster"):
            reward = self.config.damage_dealt_multiplier * damage
            self._add_reward(RewardType.DAMAGE_DEALT, reward)

    def _on_damage_taken(self, event: GameEvent):
        """Agent 受到傷害"""
        target = event.target_entity
        damage = event.data.get("damage", 0)

        # 只有 Agent 受到的傷害才懲罰
        if target and target.has_tag("player"):
            reward = self.config.damage_taken_multiplier * damage
            self._add_reward(RewardType.DAMAGE_TAKEN, reward)

    def _on_heal(self, event: GameEvent):
        """Agent 回血"""
        target = event.target_entity
        heal_amount = event.data.get("heal_amount", 0)

        if target and target.has_tag("player"):
            reward = self.config.heal_multiplier * heal_amount
            self._add_reward(RewardType.HEAL, reward)

    def _on_entity_killed(self, event: GameEvent):
        """實體被擊殺"""
        source = event.source_entity
        target = event.target_entity

        # Agent 擊殺敵人
        if source and source.has_tag("player") and target and target.has_tag("monster"):
            self._add_reward(RewardType.KILL_ENEMY, self.config.kill_enemy)

            # 檢查是否殲滅所有敵人
            if self._check_all_enemies_dead():
                self._add_reward(RewardType.ALL_ENEMIES_DEAD, self.config.all_enemies_dead)
                self._episode_done = True
                self._win = True

    def _on_skill_cast(self, event: GameEvent):
        """技能施放完成"""
        skill_id = event.data.get("skill_id", 0)

        # 召喚血包技能 (skill_id = 8)
        if skill_id == 8:
            self._add_reward(RewardType.SUMMON_BLOOD_PACK, self.config.summon_blood_pack)

    def _on_agent_died(self, event: GameEvent):
        """Agent 死亡"""
        self._add_reward(RewardType.AGENT_DIED, self.config.agent_died)
        self._episode_done = True
        self._win = False

    def _check_all_enemies_dead(self) -> bool:
        """檢查是否所有敵人都死了（需要從 world 獲取）"""
        # 這個方法需要在訓練循環中實現
        # 因為 RewardCalculator 不直接持有 world 引用
        return False  # placeholder

    # ==================== 公開介面 ====================

    def get_reward(self) -> float:
        """獲取並重置累積獎勵"""
        reward = self._accumulated_reward
        self._accumulated_reward = 0.0
        return reward

    def get_reward_breakdown(self) -> Dict[RewardType, float]:
        """獲取獎勵分解（用於調試）"""
        breakdown = self._reward_breakdown.copy()
        self._reward_breakdown.clear()
        return breakdown

    def is_episode_done(self) -> bool:
        """檢查 episode 是否結束"""
        return self._episode_done

    def is_win(self) -> bool:
        """檢查是否勝利"""
        return self._win

    def reset(self):
        """重置狀態（新 episode 時調用）"""
        self._accumulated_reward = 0.0
        self._reward_breakdown.clear()
        self._episode_done = False
        self._win = False
```

---

## 事件系統整合

### 需要新增的事件類型

```python
# core/events.py

class EventType(Enum):
    # ... 現有事件 ...

    # 新增事件
    DAMAGE_DEALT = "damage_dealt"      # Agent 造成傷害
    DAMAGE_TAKEN = "damage_taken"      # Agent 受到傷害
    HEAL = "heal"                      # Agent 回血
    AGENT_DIED = "agent_died"          # Agent 死亡
```

### 事件發布位置

| 事件 | 發布位置 |
|------|---------|
| TICK | `GameWorld.tick()` |
| ENTITY_HIT_WALL | `PhysicsSystem.move_entity()` |
| DAMAGE_DEALT | `SkillExecutor._process_result()` |
| DAMAGE_TAKEN | Monster 攻擊邏輯 |
| HEAL | `GameWorld._process_item_pickup()` |
| ENTITY_KILLED | `SkillExecutor._process_result()` |
| SKILL_CAST_COMPLETE | `SkillExecutor._execute_skill()` |
| AGENT_DIED | `GameWorld._check_agent_death()` |

---

## 與訓練循環的整合

```python
# training/trainer.py

class Trainer:
    def __init__(self, config):
        self.world = GameWorld()
        self.reward_calculator = RewardCalculator(self.world.event_bus)
        self.feature_extractor = FeatureExtractor()
        self.agent = HybridPPOAgent(...)

    def run_episode(self):
        self.world.reset()
        self.reward_calculator.reset()
        self.feature_extractor.reset()

        total_reward = 0
        trajectory = []

        while not self.reward_calculator.is_episode_done():
            # 1. 提取特徵
            state = self.feature_extractor.extract(self.world)

            # 2. Agent 選擇動作
            discrete_action, continuous_actions = self.agent.select_action(state)

            # 3. 執行動作
            self._execute_action(discrete_action, continuous_actions)

            # 4. 世界更新
            self.world.tick()

            # 5. 檢查勝利條件
            if len(self.world.monsters) == 0:
                # 所有敵人死亡
                self.world.event_bus.publish(GameEvent(
                    EventType.ALL_ENEMIES_DEAD
                ))

            # 6. 獲取獎勵
            reward = self.reward_calculator.get_reward()
            total_reward += reward

            # 7. 記錄軌跡
            next_state = self.feature_extractor.extract(self.world)
            done = self.reward_calculator.is_episode_done()
            trajectory.append((state, discrete_action, continuous_actions, reward, next_state, done))

        return trajectory, total_reward, self.reward_calculator.is_win()
```

---

## 獎勵調試工具

```python
class RewardLogger:
    """獎勵記錄工具（用於訓練分析）"""

    def __init__(self):
        self.episode_rewards: List[float] = []
        self.reward_breakdowns: List[Dict[RewardType, float]] = []
        self.win_rate_history: List[float] = []

    def log_episode(self, total_reward: float, breakdown: Dict[RewardType, float], win: bool):
        self.episode_rewards.append(total_reward)
        self.reward_breakdowns.append(breakdown)

        # 計算最近 100 局的勝率
        # ...

    def print_summary(self, last_n: int = 100):
        """打印最近 n 局的統計"""
        recent_rewards = self.episode_rewards[-last_n:]
        print(f"Average reward: {np.mean(recent_rewards):.2f}")

        # 分類統計
        totals = {rt: 0.0 for rt in RewardType}
        for breakdown in self.reward_breakdowns[-last_n:]:
            for rt, value in breakdown.items():
                totals[rt] += value

        print("Reward breakdown (last {last_n} episodes):")
        for rt, total in sorted(totals.items(), key=lambda x: x[1], reverse=True):
            avg = total / last_n
            print(f"  {rt.value}: {avg:+.2f}")
```

---

## 設計原則回顧

### 1:1 傷害比例
```python
damage_dealt_multiplier = +1.0
damage_taken_multiplier = -1.0
```
避免鼓勵送死換血。Agent 需要在「造成傷害」和「避免受傷」之間找到平衡。

### 擊殺額外獎勵
```python
kill_enemy = +20.0
```
鼓勵擊殺而非打殘。擊殺一個敵人比打傷四個敵人各 5 血更有價值。

### 自然懲罰
技能未命中沒有顯式懲罰，但會導致 CD 空窗期，Agent 會在這段時間被敵人攻擊。這是隱式的自然懲罰。

### 時間壓力
```python
tick = -0.01
```
防止 Agent 拖時間。每個 tick 都有小懲罰，鼓勵快速結束戰鬥。

---

## 可能的調優方向

如果訓練中發現問題，可以調整以下參數：

| 問題 | 可能的調整 |
|------|-----------|
| Agent 過度保守 | 降低 `damage_taken_multiplier` 絕對值 |
| Agent 過度激進 | 提高 `damage_taken_multiplier` 絕對值 |
| 不使用召喚血包 | 提高 `summon_blood_pack` |
| 只打殘不擊殺 | 提高 `kill_enemy` |
| 拖時間 | 提高 `tick` 絕對值 |
| 經常撞牆 | 提高 `hit_wall` 絕對值 |

---

## 測試方法

```python
def test_reward_calculator():
    event_bus = EventBus()
    calc = RewardCalculator(event_bus)

    # 模擬一個 tick
    event_bus.publish(GameEvent(EventType.TICK))
    assert calc.get_reward() == -0.01

    # 模擬造成 30 傷害
    event_bus.publish(GameEvent(
        EventType.DAMAGE_DEALT,
        source_entity=mock_player,
        target_entity=mock_enemy,
        data={"damage": 30}
    ))
    assert calc.get_reward() == 30.0

    # 模擬擊殺
    event_bus.publish(GameEvent(
        EventType.ENTITY_KILLED,
        source_entity=mock_player,
        target_entity=mock_enemy
    ))
    assert calc.get_reward() == 20.0
```
